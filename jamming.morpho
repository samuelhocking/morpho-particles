// Attempt to model metric jamming driven by particles embedded on mesh surface

import meshtools
import plot
import functionals

import "morpho-particles.morpho" 
import "RandomPoints.morpho"
import "ParticleOptimizer.morpho"
import "LinAlgTools.morpho"

// 1. Build substrate mesh
// var mesh = Mesh("sphere_icosa_r_1_vol_4.18879_42_vertices.mesh")
// var mesh = Mesh("sphere_icosa_r_1_vol_4.18879_162_vertices.mesh")
var mesh = Mesh("sphere_icosa_r_1_vol_4.18879_642_vertices.mesh")
// var mesh = Mesh("sphere_icosa_r_1_vol_4.18879_2562_vertices.mesh")
// var mesh = Mesh("sphere_icosa_r_1_vol_4.18879_10242_vertices.mesh")
var a = 4
var b = 1
var c = 1
var M = Matrix([
    [a,0,0],
    [0,b,0],
    [0,0,c]
])
mesh.setvertexmatrix(M*mesh.vertexmatrix())

// 2. Initialize Substrate object with substrate mesh argument
var s = Substrate(mesh)

// 3. Build particle mesh
var Np = 1000 // Number of particles
var ptsArr = GenRandomSphere(Np, r=a)
var mbb = MeshBuilder()
for (x in ptsArr) mbb.addvertex(x)
var particleMesh = mbb.build()

// 4. Initialize Particles object with particle mesh argument
var p = Particles(particleMesh)

// 5. Project particles onto substrate (Particles object method, Substrate object argument)
// p.project(s)
p.cleanProject(s, maxPoints=300, verbose=true)

var d = p.findDupes(p.points)
print("\n")
print("check:")
print("dupes : ${d.count()}")

var pproblem = OptimizationProblem(p.points)
fn f (r) {
    if (r != 0) {
        return 1/r
    } else {
        return 0
    }
}
fn gf (r) {
    if (r != 0) {
        return -1/r^2
    } else {
        return 0
    }
}
var ppot = PairwisePotential(f, gf)
pproblem.addenergy(ppot)
// pproblem.addenergy(ppot, prefactor=1)

var popt = ParticleOptimizer(pproblem, p, s)
popt.stepsize=0.001
popt.relax(20)

// 8. Invoke ParticlePlotter object
var pp = ParticlePlotter()
pp.plot(p, s, substrateGrade=[2], points=true)

var sproblem = OptimizationProblem(s.mesh)
var sarea=Area()
var svol = VolumeEnclosed()
sproblem.addenergy(sarea, prefactor=1)
sproblem.addconstraint(svol)
var sopt = SubstrateOptimizer(pproblem, sproblem, p, s)
print("substrate energy: ${sopt.totalenergy()}")

var jointOpt = JointOptimizer(
    pproblem,
    sproblem,
    p,
    s
)

// jointOpt.particleOpt.stepsize=0.001/sqrt(Np)
jointOpt.particleOpt.stepsize=0.0001
jointOpt.substrateOpt.stepsize=0.1
jointOpt.relax(1000)
print(jointOpt.energy)

// 9. Plot
pp.plot(p, s, substrateGrade=[2], points=true)

