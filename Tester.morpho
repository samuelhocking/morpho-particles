// Tester object to facilitate timing callable performance
// By: Sam Hocking

import meshtools
import constants
import "Particles.morpho"
import "RandomPoints.morpho"
import "dictToPython.morpho"
import "TimingFuncs.morpho"

fn nVertexCylinder(numVerts, r=1) {
    var uSteps = ceil(sqrt(numVerts))
    var vSteps = ceil(numVerts/uSteps)
    var uInc = 2*Pi/(vSteps-1)
    var vInc = 2*r/(uSteps-1)
    var m = AreaMesh(fn (u, v) [
        v,
        r*cos(u),
        r*sin(u)], 0...2*Pi:uInc, -r..r:vInc, closed=[true, false])
    m.addgrade(1)
    return m
}

class Tester{
    init() {
        self.timingDictArr = []
    }
    setTestParams(paramsFunc) {
        paramsFunc()
    }
    varyNumPoints(numPtsRng, numVerts, numTrials) {
        self.variedParam = "numPts"
        self.variedParamRng = numPtsRng
        self.staticParam = "numVerts"
        self.staticParamVal = numVerts
        self.numTrials = numTrials
    }
    varyNumVerts(numVertsRng, numPts, numTrials) {
        self.variedParam = "numVerts"
        self.variedParamRng = numVertsRng
        self.staticParam = "numPts"
        self.staticParamVal = numPts
        self.numTrials = numTrials
    }

    call(func=nil, timingflag=true, name=nil, timingfunc=nil, dict=nil, trialNum=1) {
        if (timingflag == true) {
            var result = timingfunc(func)
            if (trialNum == 1) {
                dict[name] = (result.elapsed)/self.numTrials
            } else {
                dict[name] += ((result.elapsed)/self.numTrials)
            }
            return result.out
        } else {
            return func
        }
    }

    testLoop(timingfunc, quiet=true, projectTimingFlag=false, moveAllTimingFlag=false) {
        var numScens = self.variedParamRng.count()
        var mesh, ptsArr
        for (i in 0...numScens) {
            if (quiet == false) {
                print "Starting scenario ${i+1}/${numScens}"
            }
            var timingDict = Dictionary()
            if (self.variedParam == "numPts") {
                mesh = nVertexCylinder(self.staticParamVal)
                ptsArr = GenRandomRectangle(self.variedParamRng[i], xBounds=[-2,2], yBounds=[-2,2], zBounds=[-2,2])
                var numPts = ptsArr.count()
                var numVerts = mesh.count(0)
                timingDict[self.variedParam] = numPts       
                timingDict[self.staticParam] = numVerts
            } else {
                mesh = nVertexCylinder(self.variedParamRng[i])
                ptsArr = GenRandomRectangle(self.staticParamVal, xBounds=[-2,2], yBounds=[-2,2], zBounds=[-2,2])
                var numPts = ptsArr.count()
                var numVerts = mesh.count(0)
                timingDict[self.staticParam] = numPts       
                timingDict[self.variedParam] = numVerts
            }
            for (j in 1..self.numTrials) {
                if (quiet == false) {
                    print "Starting trial ${j}/${self.numTrials} [scenario ${i+1}/${numScens}]"
                }
                var p = Particles(mesh, testing=true, timingfunc=timingfunc, numTestTrials=self.numTrials)
                if (j == 1) {
                    for (k in p.testDict) {
                        timingDict[k] = p.testDict[k]
                    }
                } else {
                    for (k in p.testDict) {
                        timingDict[k] += p.testDict[k]
                    }
                }
                self.call(func=p.project(ptsArr), timingflag=projectTimingFlag, timingfunc=timingfunc, name="project", dict=timingDict, trialNum=j)
                self.call(func=p.moveAll(ConstantForce(Matrix([1,0,0]) + Matrix([0,0,1])), quiet=true), timingflag=moveAllTimingFlag, timingfunc=timingfunc, name="moveAll", dict=timingDict, trialNum=j)
            }
            self.timingDictArr.append(timingDict)
        }
    }
    exportTimingDictArr() {
        system(dictArrToPython(self.timingDictArr, "dictPlotter.py", self.variedParam, delim="!"))
    }
}