// Attempt to model metric jamming driven by particles embedded on mesh surface

import meshtools
import plot
import functionals
import color

import "morpho-particles.morpho" 
import "RandomPoints.morpho"
import "ParticleOptimizer.morpho"
import "LinAlgTools.morpho"
import "moviemaker.morpho"
import "TimingFuncs.morpho"

fn bfunc(a, vol_0) {
    return sqrt(3*vol_0/(4*a*Pi))
}
fn rad(vol_0) {
    return (3*vol_0/(4*Pi))^(1/3)
}
fn sphere_area(r) {
    return 4*Pi*r^2
}
fn sphere_vol(r) {
    return 4/3*Pi*r^3
}
fn ellipsoid_area(a,b,c) {
    return 4*Pi*(((a*b)^1.6075+(a*c)^1.6075+(b*c)^1.6075)/3)^(1/1.6075)
}
fn ellipsoid_vol(a,b,c) {
    return 4/3*Pi*a*b*c
}
fn thomson_func (r) {
    if (r != 0) {
        return 1/r
    } else {
        return 0
    }
}
fn thomson_grad (r) {
    if (r != 0) {
        return -1/r^2
    } else {
        return 0
    }
}
fn hertzian_func (sigma=0.1, V0=100) {
    sigma = sigma
    V0 = V0
    fn inner(r) {
        if (r < sigma) {
            return V0*(1-r/sigma)^(5/2)
        } else {
            return 0
        }
    }
    return inner
}
fn hertzian_grad (sigma=0.1, V0=100) {
    sigma = sigma
    V0 = V0
    fn inner(r) {
        if (r < sigma) {
            return -5*V0/(2*sigma)*(1-r/sigma)^(3/2)
        } else {
            return 0
        }
    }
    return inner
}
fn dynamic_sigma(tgtSigma, initSigma, tgtArea, c=1, d=0, e=0) {
    tgtSigma = tgtSigma
    initSigma = initSigma
    tgtArea = tgtArea
    c = c
    fn inner(area) {
        return initSigma + 1/2*(tgtSigma-initSigma)*(1+tanh(c*(tgtArea-area)+d*5/4*Pi))
        // return initSigma + 1/2*(tgtSigma-initSigma)*(1+tanh(c*(tgtArea-area)+d*5/4*Pi))+e*max(0,tgtArea-area)*(tgtSigma-initSigma)
    }
    return inner
    return inner
}

var t = takeTime("t.txt")

// 1. Build substrate mesh
var nverts = 162 // options: 42, 162, 642, 2562, 10242
var mesh = Mesh("./meshes/sphere_icosa_r_1_vol_4.18879_${nverts}_vertices.mesh")
var a_0 = 2
var b_0 = 1
var c_0 = 1
var M = Matrix([
    [a_0,0,0],
    [0,b_0,0],
    [0,0,c_0]
])
mesh.setvertexmatrix(M*mesh.vertexmatrix())

// 2. Initialize Substrate object with substrate mesh argument
var s = Substrate(mesh)

// 3. Build particle mesh
var Np = 500 // Number of particles
// Find Thomson solution for this ellipsoid
// var ptsArr = GenRandomSphere(Np, r=a)
// var mbb = MeshBuilder()
// for (x in ptsArr) mbb.addvertex(x)
// var particleMesh = mbb.build()
// particleMesh.save("particleMesh_${t}.mesh")

// Load Thomson solution for this ellipsoid
var particleMesh = Mesh("./meshes/a${a_0}_b${b_0}_c${c_0}_Np${Np}_sverts${nverts}_thomson.mesh")

// 4. Initialize Particles object with particle mesh argument
var p = Particles(particleMesh)

// 5. Project particles onto substrate (Particles object method, Substrate object argument)
p.project(s)
// p.cleanProject(s, maxPoints=100, verbose=true)

var vol_0 = ellipsoid_vol(a_0,b_0,c_0)
print("constant initial volume: ${vol_0}")
print("equivalent spherical radius: ${rad(vol_0)}")
print("equivalent spherical area: ${sphere_area(rad(vol_0))}")

print("")
print("jamming targets")
var tgt_jammed_a = 1.85
var tgt_jammed_b = bfunc(tgt_jammed_a, vol_0)
var tgt_jammed_area = ellipsoid_area(tgt_jammed_a, tgt_jammed_b, tgt_jammed_b)
print("a: ${tgt_jammed_a} b: ${tgt_jammed_b} area: ${tgt_jammed_area}}")
var tgt_coverage_fraction = 0.9 // this is really ~0.9 but I want to skew towards jamming (larger sigma*)vs. not
var tgt_sigma = 2*sqrt(tgt_coverage_fraction*tgt_jammed_area/(Np*Pi))
print("tgt sigma: ${tgt_sigma}")
var using_sigma = tgt_sigma
print("using sigma: ${using_sigma}")
var init_sigma = 0.01

// Set up problems
var sproblem = OptimizationProblem(s.mesh)
var sarea=Area()
var svol = VolumeEnclosed()
sproblem.addenergy(sarea)
sproblem.addconstraint(svol)

var pproblem = OptimizationProblem(p.points)
var ppot = PairwisePotential(hertzian_func(sigma=init_sigma, V0=Np),hertzian_grad(sigma=init_sigma, V0=Np))
pproblem.addenergy(ppot)

var sopt = SubstrateOptimizer(pproblem, sproblem, p, s, maxForceNorm=0.05)
var popt = ParticleOptimizer(pproblem, p, s)

sopt.quiet=true
// popt.quiet=true
sopt.stepsize = 0.01
popt.stepsize = 1e-5

var relaxCycles = 2000
var cycleSubsteps = 200

// var ds = dynamic_sigma(using_sigma, init_sigma, tgt_jammed_area, c=5)
var ds = dynamic_sigma(using_sigma, init_sigma, tgt_jammed_area, c=20, d=1, e=1)

var mm_z = MovieMaker("${t}_jam_view_z_a${a_0}_b${b_0}_c${c_0}_Np${Np}_sigma${using_sigma}_iters${relaxCycles}_substeps${cycleSubsteps}_soptstep${sopt.stepsize}_poptstep${popt.stepsize}")
mm_z.framerate = 30
mm_z.viewpoint = Matrix([0,0,5])
mm_z.viewangle = 50
var mm_x = MovieMaker("${t}_jam_view_x_a${a_0}_b${b_0}_c${c_0}_Np${Np}_sigma${using_sigma}_iters${relaxCycles}_substeps${cycleSubsteps}_soptstep${sopt.stepsize}_poptstep${popt.stepsize}")
mm_x.framerate = 30
mm_x.viewpoint = Matrix([5,0,0])    
mm_x.viewangle = 50
var mm_neg_x = MovieMaker("${t}_jam_view_negx_a${a_0}_b${b_0}_c${c_0}_Np${Np}_sigma${using_sigma}_iters${relaxCycles}_substeps${cycleSubsteps}_soptstep${sopt.stepsize}_poptstep${popt.stepsize}")
mm_neg_x.framerate = 30
mm_neg_x.viewpoint = Matrix([-5,0,0])
mm_neg_x.viewangle = 50
var mm_iso = MovieMaker("${t}_jam_view_iso_a${a_0}_b${b_0}_c${c_0}_Np${Np}_sigma${using_sigma}_iters${relaxCycles}_substeps${cycleSubsteps}_soptstep${sopt.stepsize}_poptstep${popt.stepsize}")
mm_iso.framerate = 30
mm_iso.viewpoint = Matrix([5,5,5])*5/Matrix([5,5,5]).norm()
mm_iso.viewangle = 50
mm_iso.sky = Matrix([-1,2,-1])

var substrate_energies = [sopt.totalenergy()]
var particle_energies = [popt.totalenergy()]

var newppot
var newSigma = init_sigma
for (i in 0...relaxCycles) {
    sopt.relax(1)
    s.updateCoords()
    sopt.settarget(s.mesh.vertexmatrix())
    p.updateCartesianCoords(s)
    popt.settarget(p.points.vertexmatrix())
    newSigma = max(newSigma, ds(sopt.totalenergy()))
    newppot = PairwisePotential(hertzian_func(sigma=newSigma, V0=Np), hertzian_grad(sigma=newSigma, V0=Np))
    pproblem.energies[0].functional = newppot
    popt.relax(cycleSubsteps)
    substrate_energies.append(sopt.totalenergy())
    particle_energies.append(popt.totalenergy())
    var g = Graphics()
    g += plotmesh(s.mesh, grade=[2])
    for (i in 0...p.points.count(0)) {
        g.display(Sphere(p.points.vertexposition(i), newSigma/2, color=Green))
    }
    for (obj in [mm_z, mm_x, mm_neg_x, mm_iso]) {
        var gtext = Graphics()
        gtext.display(Text("iter: ${i}", [1,1.5,0], size=12, dirn=cross(obj.viewpoint, -1*obj.sky), vertical=obj.sky))
        gtext += g
        obj.frame(gtext)
    }
    print("iter: ${i}  area: ${substrate_energies[-1]} (delta E: ${substrate_energies[-1]-substrate_energies[-2]}) pw energy: ${particle_energies[-1]} (delta E: ${particle_energies[-1]-particle_energies[-2]}) tgt area: ${tgt_jammed_area} tgtSigma: ${using_sigma} newSigma: ${newSigma} stepsize: ${sopt.stepsize}")
}

mm_z.make()
mm_x.make()
mm_neg_x.make()
mm_iso.make()
mm_z.clean()
mm_x.clean()
mm_neg_x.clean()
mm_iso.clean()

var pp = ParticlePlotter()
pp.plot(p, s, substrateGrade=[2], points=true, particleRad=newSigma/2)

p.points.save("./meshes/pmesh_${t}_jam_a${a_0}_b${b_0}_c${c_0}_Np${Np}_sigma${using_sigma}_iters${relaxCycles}_substeps${cycleSubsteps}_soptstep${sopt.stepsize}_poptstep${popt.stepsize}.mesh")
s.mesh.save("./meshes/smesh_${t}_jam_a${a_0}_b${b_0}_c${c_0}_Np${Np}_sigma${using_sigma}_iters${relaxCycles}_substeps${cycleSubsteps}_soptstep${sopt.stepsize}_poptstep${popt.stepsize}.mesh")