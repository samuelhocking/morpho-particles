// Script to project arbitary points in R^3 onto a mesh surface
// By: Sam Hocking
// Updated: 7/5/2022

import meshtools
import plot
import optimize
import kdtree
import constants
import implicitmesh

var version = "v17"
import "Particles_v17.morpho"
// var version = "live"
// import "Particles_live.morpho"
import "dictToPython.morpho"

// var numProjPtsRng = 10000..200000:10000
// var numProjPtsRng = 1000..20000:1000 // standard
// var meshDimRng = 5..5 // standard
// var xfield = "num points"
var numProjPtsRng = 1000..1000 // standard
// var meshDimRng = 10..100:10
var meshDimRng = 1..10:1 // standard
var xfield = "num vertices"
var numTrials = 2
var dictArr = []
var vh
var numPts
for (m in numProjPtsRng) {
    for (d in meshDimRng) {
        print"starting: ${m} pts / ${d} dim"
        var resArr = Matrix(Array(10))
        for (t in 1..numTrials) {

            //initialize a few timer helper objects
            var timer=timerClass() // for aggregate level calls
            var timerTwo=timerClass() // for each kd-tree search
            var timerThree=timerClass() // for each star construction
            var timerFour=timerClass() // for each projection (whole process including finding closest face)

            //options of meshes to test projection
            timer.timerStart()
            var mesh

            /*
            //Tetrahedron
            var verts = [[0, 0.57735027, -0.25],[-0.5,-0.28867513,-0.25],[0.5,-0.28867513,-0.25],[0,0,0.5]]
            var edges = [[0,1],[0,2],[1,2],[0,3],[1,3],[2,3]]
            var faces = [[0,1,2],[0,1,3],[1,2,3],[0,2,3]]
            var mb = MeshBuilder()
            for (v in verts) mb.addvertex(v)
            for (e in edges) mb.addedge(e)
            for (f in faces) mb.addface(f)
            var tetra = mb.build()
            mesh = tetra
            var meshName = "tetrahedron"
            */

            /*
            // Torus
            var r=1
            var a=0.35
            var impl = ImplicitMeshBuilder(fn (x,y,z) (x^2+y^2+z^2+r^2-a^2)^2 - 4*r^2*(x^2+y^2))
            var torus = impl.build(start=Matrix([1,0,0.5]), stepsize=0.25, maxiterations=400)
            torus.addgrade(1)
            mesh = torus
            var meshName = "torus"
            */

            /*
            // 3-surface
            var rx=6
            var ry=3.5
            var rz=4
            var r1=1.2
            var x1=3.9
            var impl = ImplicitMeshBuilder(fn (x,y,z) rz^4*z^2 - (1-(x/rx)^2-(y/ry)^2)*((x-x1)^2 + y^2 - r1^2)*(x^2+y^2-r1^2)*((x+x1)^2+y^2-r1^2))
            var threesurf = impl.build(start=Matrix([0,3,0]), stepsize=0.3, maxiterations=4000)
            threesurf.addgrade(1)
            mesh = threesurf
            var meshName = "threesurface"
            */

            
            // re-sizable torus (to test)
            var R=2
            var r=0.5
            var tor = AreaMesh(fn (u, v) [(R+r*cos(u))*cos(v), (R+r*cos(u))*sin(v), r*sin(u)], -Pi...Pi:Pi/(5), -Pi...Pi:Pi/(5*d), closed=[true, true])
            tor.addgrade(1)
            mesh = tor
            var meshName = "torus"


            timer.timerStop()

            timer.timerStart()
            var meshConn = MeshConnectivity(mesh)
            timer.timerStop()

            timer.timerStart()
            vh = VertexHelper(meshConn)
            timer.timerStop()

            timer.timerStart()
            var facekd = faceKDHelper(meshConn)
            var edgekd = edgeKDHelper(meshConn)
            var sh = StarHelper(vh, facekd, edgekd)
            var sfh = SimpleFaceHelper(facekd, edgekd)
            timer.timerStop()

            timer.timerStart()
            var kd = KDHelper(mesh)
            timer.timerStop()


            timer.timerStart()
            //projectable point cloud options
            var ptsArr = []

            /*
            //generate closed ball (i.e., contains interior points) projectable point cloud
            var x, y, z
            var r = 2
            var usteps = 10
            var vsteps = 50
            var wsteps = 5
            for (var u=0; u<=usteps; u+=1) {
                for (var v=0; v<vsteps; v+=1) {
                    for (var w=0; w<=wsteps; w+=1) {
                        x = (w/wsteps*r)*sin(u/usteps*Pi)*cos(v/vsteps*2*Pi)
                        y = (w/wsteps*r)*sin(u/usteps*Pi)*sin(v/vsteps*2*Pi)
                        z = (w/wsteps*r)*cos(u/usteps*Pi)
                        ptsArr.append(Matrix([x,y,z]))
                    }
                }
            }
            var numPts = ptsArr.count()
            */


            //generate random point cloud
            numPts = m
            var xbounds = 2*Matrix([-1,1])
            var ybounds = 2*Matrix([-1,1])
            var zbounds = 2*Matrix([-1,1])
            var xrange = xbounds[1] - xbounds[0]
            var yrange = ybounds[1] - ybounds[0]
            var zrange = zbounds[1] - zbounds[0]
            for (i in 1..numPts) {
                ptsArr.append(Matrix([
                    xbounds[0] + xrange*random(),
                    ybounds[0] + yrange*random(),
                    zbounds[0] + zrange*random()
                    ]))
            }
            timer.timerStop()


            timer.timerStart()
            var projPts = []
            var p_c
            var star_c
            var mp_c
            var x_proj_res, x_proj
            for (x in ptsArr) {

                timerFour.timerStart()
                timerTwo.timerStart()
                p_c = kd.tree.nearest(x).id
                timerTwo.timerStop()

                mp_c = StarProjector(starHelperObj=sh, centerIndex=p_c)

                timerThree.timerStart()
                x_proj = mp_c.getClosestMeshPt(x=x)[0]
                // x_proj_res = mp_c.getClosestMeshPt(x=x)
                // x_proj = x_proj_res[0]
                timerThree.timerStop()
                timerFour.timerStop()

                projPts.append(x_proj)
            }
            timer.timerStop()

            /*
            timer.timerStart()
            var gMesh = plotmesh(mesh, grade=[2])
            var gCombined = gMesh
            var gPt
            for (pt in ptsArr) {
                gPt = Graphics()
                gPt.display(Sphere(pt, 0.02, color=[0,0,255]))
                gCombined += gPt.clone()
            }
            var gProjPt
            for (pt in projPts) {
                gProjPt = Graphics()
                gProjPt.display(Sphere(pt, 0.02, color=[255,0,0]))
                gCombined += gProjPt.clone()
            }
            Show(gCombined)
            timer.timerStop()
            */

            //generate mesh, mesh connectivity, VertexHelperObj, StarHelperObj, kd-tree creation, generate point cloud, projection loop
            // print timer.clockTimeArr
            // print "total 'time': ${Matrix(timer.clockTimeArr).sum()}" // total
            // print "total kd-tree 'time': ${Matrix(timerTwo.clockTimeArr).sum()}" // kd tree searches
            // print "total projection 'time': ${Matrix(timerFour.clockTimeArr).sum()}" // projection
            // print "total projection loop 'time': ${Matrix(timerTwo.clockTimeArr).sum() + Matrix(timerThree.clockTimeArr).sum() + Matrix(timerFour.clockTimeArr).sum()}"
            resArr += 1/numTrials * Matrix([
                timer.clockTimeArr[0],
                timer.clockTimeArr[1],
                timer.clockTimeArr[2],
                timer.clockTimeArr[3],
                timer.clockTimeArr[4],
                timer.clockTimeArr[5],
                Matrix(timer.clockTimeArr).sum(),
                Matrix(timerTwo.clockTimeArr).sum(),
                Matrix(timerThree.clockTimeArr).sum(),
                Matrix(timerFour.clockTimeArr).sum()
            ])
            print"   done: ${t}/${numTrials} trials"
        }
        var resDict = Dictionary()
        //resDict["mesh name"] = meshName
        resDict["num vertices"] = vh.numVerts
        resDict["num points"] = numPts
        resDict["mesh generation"] = resArr[0]
        resDict["mesh connectivity"] = resArr[1]
        resDict["vertexHelper"] = resArr[2]
        resDict["starHelper"] = resArr[3]
        resDict["kd-tree build"] = resArr[4]
        resDict["point cloud generation"] = resArr[5]
        resDict["total"] = resArr[6]
        resDict["kd-tree search"] = resArr[7]
        resDict["projection process"] = resArr[8]
        resDict["projection loop"] = resArr[9]
        dictArr.append(resDict)
        print"done: ${m} pts/ ${vh.numVerts} vertices"
    }
}

// system(dictToPython(resDict,pyFile="dictPlotter.py"))
// system(dictArrToPython(dictArr, "dictPlotter.py", "num points"))
// system(dictArrToPython(dictArr, "dictPlotter.py", "num vertices"))
system(dictArrToPython(dictArr, "dictPlotter.py", xfield, version))

// //need to make file if it doesnt exist - python script best? probably
// //system()
// var f = File("results_${meshName}_${vh.numVerts}verts_${numPts}pts.csv")
// for (k, val in resDict) f.write("${k}, ${val}")
// f.close()