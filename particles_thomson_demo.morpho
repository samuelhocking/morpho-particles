// Demo of particle projection and movement
// By: Sam Hocking

import meshtools
import plot
import optimize
import "Particles.morpho"
import "RandomPoints.morpho"

// Sphere
// var r=1
// var impl = ImplicitMeshBuilder(fn (x,y,z) x^2+y^2+z^2-r^2)
// var sphere = impl.build(start=Matrix([1,0,0]), stepsize=0.25, maxiterations=400)
// sphere.addgrade(0)
// sphere.addgrade(1)
// sphere.addgrade(2)
// var mesh = sphere

//Sphere
var cube = PolyhedronMesh(
    [[-0.5,-0.5,-0.5],
     [-0.5,0.5,-0.5],
     [0.5,-0.5,-0.5],
     [0.5,0.5,-0.5],
     [-0.5,-0.5,0.5],
     [-0.5,0.5,0.5],
     [0.5,-0.5,0.5],
     [0.5,0.5,0.5]],
    [[0,1,3,2],
     [0,1,5,4],
     [2,3,7,6],
     [1,3,7,5],
     [0,2,6,4],
     [4,5,7,6]])
cube.addgrade(1)
var problem = OptimizationProblem(cube)
// surface tension
var la=Area()
// volume constraint
var lv = VolumeEnclosed()
problem.addenergy(la)
problem.addconstraint(lv)

var leq=EquiElement()
var reg = OptimizationProblem(cube)
reg.addenergy(leq)
var ropt = ShapeOptimizer(reg, cube)

var opt = ShapeOptimizer(problem, cube)
opt.stepsize = 0.001

var refmax = 3
for (refiter in 1..refmax) {
    for (i in 1..10) {
        print "-Regularize"
        ropt.linesearch(3)
        equiangulate(cube)
        opt.relax(100)
    }
    if (refiter==refmax) break
    var mr=MeshRefiner([cube])
    var refmap=mr.refine()
    for (el in [problem, opt, reg, ropt]) el.update(refmap)
    cube=refmap[cube]
}
var mesh = cube

// generate random point cloud
var ptsArr = GenRandomRectangle(100, xBounds=[-2,2], yBounds=[-2,2], zBounds=[-2,2])

var p = Particles(mesh)
p.project(ptsArr)

var steps = 200
for (i in 1..steps) {
    if (mod(i,10)==0) {
        print "starting step: ${i}"
    }
    p.moveAll(PairwiseForces(p.pointLocs), stepsize=0.0001, quiet=true)
}

var gMesh = plotmesh(mesh, grade=[2])
var gCombined = gMesh
var gMovedPt
for (i in 0...p.points.count()) {
    gMovedPt = Graphics()
    gMovedPt.display(Sphere(p.points[i].particleinfo[0], 0.02, color=[0,255,0]))
    gCombined += gMovedPt.clone()
    print "Rendering: ${i+1}/${p.points.count()}"
}
Show(gCombined)