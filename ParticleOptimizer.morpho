// Particle optimizer
// By: Sam Hocking

import optimize

class ParticleOptimizer is ShapeOptimizer {
    init(particleProblem, particlesObj, substrateObj) {
        super.init(particleProblem, particlesObj.points)
        self.particlesObj = particlesObj
        self.substrateObj = substrateObj
    }

    /* Perform relaxation at fixed stepsize */
    relax(n) {
        if (self.energy.count()==0) self.energy.append(self.totalenergy())

        for (i in 0...n) {
            self.force = self.totalforcewithconstraints()
            self.step(self.stepsize)
            self.energy.append(self.totalenergy()) // Track the total energy
            self.report(i)
            if (self.hasconverged()) break
        }
        return self.energy
    }

    /* Take a step */
    step(stepsize) {
        // var target = self.gettarget()
        var frc = self.force*stepsize*(-1) // Use the force
        if (!frc) return

        self.particlesObj.points.vertexmatrix().acc(1,frc)
        self.particlesObj.projectPoints(self.substrateObj)
        self.settarget(self.particlesObj.points.vertexmatrix())
    }
}

class SubstrateOptimizer is ShapeOptimizer {
    init(particleProblem, substrateProblem, particlesObj, substrateObj, maxForceNorm=nil) {
        super.init(substrateProblem, substrateObj.mesh)
        self.particleProblem = particleProblem
        self.substrateProblem = substrateProblem
        self.particlesObj = particlesObj
        self.substrateObj = substrateObj
        self.maxForceNorm = maxForceNorm
    }

    getSubstrateVertexGrad(stepsize=0.0001) {
        var I = Eye(3)

        var substrateVertexGrad = Matrix(3, self.substrateObj.mesh.count(0))
        for (i in 0...self.substrateObj.mesh.count(0)) {
            var grads = []
            for (j in 0..2) {
                self.substrateObj.mesh.vertexmatrix().setcolumn(i, self.substrateObj.mesh.vertexmatrix().column(i) + stepsize*I.column(j))
                self.particlesObj.updateCartesianCoords(self.substrateObj)
                // var fplus = self.particleProblem.totalenergy()
                var fplus = self.totalParticleEnergy()

                self.substrateObj.mesh.vertexmatrix().setcolumn(i, self.substrateObj.mesh.vertexmatrix().column(i) - 2*stepsize*I.column(j))
                self.particlesObj.updateCartesianCoords(self.substrateObj)
                // var fminus = self.particleProblem.totalenergy()
                var fminus = self.totalParticleEnergy()

                self.substrateObj.mesh.vertexmatrix().setcolumn(i, self.substrateObj.mesh.vertexmatrix().column(i) + stepsize*I.column(j))
                self.particlesObj.updateCartesianCoords(self.substrateObj)

                grads.append((fplus-fminus)/(2*stepsize))
            }
            // print("done: ${i}/${p.numPoints-1}")
            // print("gradient")
            // print(grads)
            substrateVertexGrad.setcolumn(i, Matrix(grads))
        }
        return substrateVertexGrad
    }

    totalParticleEnergy() {
        var energy = 0
        for (en in self.particleProblem.energies) {
            energy+=self.total(en)
        }
        return energy    
    }

    capForce(force) {
        if ((force.norm() < 1e-10) or (self.maxForceNorm == nil)) {
            return force
        } else {
            var norms = []
            var min_idx
            var max_idx
            var min_norm
            var max_norm
            for (i in 0...force.dimensions()[1]) {
                var n = force.column(i).norm()
                if (i == 0) {
                    min_idx = 0
                    max_idx = 0
                    min_norm = n
                    max_norm = n
                } else {
                    if (n < min_norm) {
                        min_norm = n
                        min_idx = i
                    }
                    if (n > min_norm) {
                        max_norm = n
                        max_idx = i
                    }
                }
                norms.append(force.column(i).norm())
            }
            var factor = self.maxForceNorm/(self.stepsize*max_norm)
            if (factor < 1) {
                return force * factor
            } else {
                return force
            }
        }
    }


    totalforcewithconstraints() {
        var f = self.totalforce() + self.getSubstrateVertexGrad(stepsize=self.stepsize)
        var ff = self.capForce(f)
        self.initlocalconstraints() // Find which local constraints are active
        self.subtractlocalconstraints(f) // Remove projections onto local constraints
        self.subtractconstraints(f) // Remove projections onto constraint directions
        return f
    }

    /* Perform relaxation at fixed stepsize */
    relax(n) {
        if (self.energy.count()==0) self.energy.append(self.totalenergy())

        for (i in 0...n) {
            self.force = self.totalforcewithconstraints()
            self.step(self.stepsize)
            self.energy.append(self.totalenergy()) // Track the total energy
            self.report(i)
            if (self.hasconverged()) break
        }
        return self.energy
    }

    /* Take a step */
    step(stepsize) {
        var target = self.gettarget()
        var frc = self.force // Use the force

        if (!frc) return

        target.acc(-stepsize, frc) // Take a step

        self.initlocalconstraints()
        self.reprojectlocalconstraints() // Reproject onto local constraints
        self.reprojectconstraints() // Push back onto constraints
        self.settarget(self.substrateObj.mesh.vertexmatrix())
    }
}

class JointOptimizer is ShapeOptimizer {
    init(particleProblem, substrateProblem, particlesObj, substrateObj, movieMakerObj=nil) {
        self.particleProblem = particleProblem
        self.substrateObj = substrateProblem
        self.particlesObj = particlesObj
        self.substrateObj = substrateObj
        self.movieMakerObj = movieMakerObj
        self.particleOpt = ParticleOptimizer(particleProblem, particlesObj, substrateObj)
        self.substrateOpt = SubstrateOptimizer(particleProblem, substrateProblem, particlesObj, substrateObj)
        self.energy = [] // History of energies
        self.etol = 1e-8 // Energy convergence criterion
        self.ctol = 1e-10 // Constraint satisfaction criterion
        self.particleOpt.etol = self.etol
        self.particleOpt.ctol = self.ctol
        self.substrateOpt.etol = self.etol
        self.substrateOpt.ctol = self.ctol
        self.quiet = false
        self.particleOpt.quiet = true
        self.substrateOpt.quiet = true
    }

    relax(n, film=false) {
        if (self.particleOpt.energy.count()==0) self.particleOpt.energy.append(self.particleOpt.totalenergy())
        if (self.substrateOpt.energy.count()==0) self.substrateOpt.energy.append(self.substrateOpt.totalenergy())
        if (self.energy.count()==0) self.energy.append(self.particleOpt.totalenergy()+self.substrateOpt.totalenergy())
        if (self.quiet == false)
            print(
                "Initial energies.
            Total     | Energy: ${self.energy[-1]}
            Substrate | Energy: ${self.substrateOpt.energy[-1]}
            Particles | Energy: ${self.particleOpt.energy[-1]}"
                )
        for (i in 0...n) {
            self.particleOpt.force = self.particleOpt.totalforcewithconstraints()
            var regularSubstrateForces = self.substrateOpt.totalforcewithconstraints()
            var particleSubstrateForces = self.substrateOpt.getSubstrateVertexGrad()
            // var normed_regularSubstrateForces = regularSubstrateForces.clone()
            // var normed_particleSubstrateForces = particleSubstrateForces.clone()
            // for (i in 0...normed_regularSubstrateForces.dimensions()[1]) {
            //     var x = normed_regularSubstrateForces.column(i)
            //     if (x.norm() > 1e-10) {
            //         normed_regularSubstrateForces.setcolumn(i, x/x.norm())
            //     }
            // }
            // for (i in 0...normed_particleSubstrateForces.dimensions()[1]) {
            //     var x = normed_particleSubstrateForces.column(i)
            //     if (x.norm() > 1e-10) {
            //         normed_particleSubstrateForces.setcolumn(i, x/x.norm())
            //     }
            // }
            // var dots = normed_regularSubstrateForces.transpose() * normed_particleSubstrateForces
            // print("orthogonality")
            // print(dots.sum()/dots.count())
            self.substrateOpt.force = regularSubstrateForces + particleSubstrateForces
            self.substrateOpt.step(self.substrateOpt.stepsize)
            self.substrateObj.updateCoords()
            self.particleOpt.step(self.particleOpt.stepsize)
            self.substrateOpt.settarget(self.substrateObj.mesh.vertexmatrix())
            self.particleOpt.settarget(self.particlesObj.points.vertexmatrix())
            self.particleOpt.energy.append(self.particleOpt.totalenergy())
            self.substrateOpt.energy.append(self.substrateOpt.totalenergy())
            self.energy.append(self.particleOpt.totalenergy()+self.substrateOpt.totalenergy())
            self.report(i)
            if (film == true) {
                var g = Graphics()
                g += plotmesh(self.substrateObj.mesh, grade=[2])
                for (i in 0...self.particlesObj.points.count(0)) {
                    g.display(Sphere(self.particlesObj.points.vertexposition(i), 0.05, color=Green))
                }              
                self.movieMakerObj.frame(g)
            }
            // print(" particle  force norm  : ${self.particleOpt.totalforcewithconstraints().norm()}")
            // print(" substrate force norm  : ${self.substrateOpt.totalforcewithconstraints().norm()}")
            // print(" substrate vertex norm : ${self.substrateOpt.getSubstrateVertexGrad().norm()}")
            if (self.hasconverged()) break
        }
    }

    hasconverged() {
        var energy = self.energy
        if (energy.count()>1) {
            var de = abs(energy[-1]-energy[-2])
            if (abs(energy[-1])<self.etol || de/abs(energy[-1])<self.etol) return true
        }
        return false
    }

    report(iter) {
        if (self.energy.count()<2) return
        var de = abs(self.energy[-1]-self.energy[-2])
        var sde = abs(self.substrateOpt.energy[-1]-self.substrateOpt.energy[-2])
        var pde = abs(self.particleOpt.energy[-1]-self.particleOpt.energy[-2])
        if (!self.quiet) {
            print(
                "Iteration ${iter}.
        Total     | Energy: ${self.energy[-1]} delta E: ${de}
        Substrate | Energy: ${self.substrateOpt.energy[-1]} delta E: ${sde} stepsize: ${self.substrateOpt.stepsize}
        Particles | Energy: ${self.particleOpt.energy[-1]} delta E: ${pde} stepsize: ${self.particleOpt.stepsize}"
            )
        }
    }
}
